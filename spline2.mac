load("spline-utils.mac");

/*

http://duns.sourceforge.net/fig1.png
http://en.wikipedia.org/wiki/Transfinite_interpolation

*/
%x%(s):=ax*s + bx;
%y%(s):=ay*s + by;
%so%: first(solve([%x%(0)=x1, %y%(0)=y1, %x%(1)=x2,  %y%(1)=y2], [ax, bx, ay, by]));

element_length(c):= error("not impl.");

/* create parameteric line from [x1, y1] to [x2, y2]
p: create_line(0, 0, 1, 2);
draw2d(parametric( p(s)[1], p(s)[2], s, 0, 1));
*/
create_line([l]):= apply(create_line_aux, flatten(l));
create_line_aux(x1, y1, x2, y2):= buildq([X: ev(subst(%so%, %x%(s))), Y: ev(subst(%so%, %y%(s)))],
  lambda([s], [X, Y]));

/* create parameteric arc with a center [xc, yc] 
p: create_arc( [1, 1], 2, 45, 45+180 );
draw2d(xrange=[-3, 3], yrange=[-3, 3], parametric( p(s)[1], p(s)[2], s, 0, 1));
*/
create_arc([l]):= apply(create_arc_aux, flatten(l));
create_arc_aux(xc, yc, radius, phi_start, phi_end):= block([s],
  buildq([xc, yc, radius, sc: change_scale(0, 1, phi_start, phi_end)(s)],
    lambda([s], [xc + radius*cos(sc/180*%pi), yc + radius*sin(sc/180*%pi)])));

join_elements(el1, L1, el2, L2):= block([
  pivot: L1/(L1+L2),
  sc1: (L1+L2)/L1,
  sc2: (L1+L2)/L2],
  buildq([pivot, sc1, sc2, el1, el2],
    lambda([s], 
      el1(sc1*s)* charfun2(s, minf, pivot) + el2( (s - pivot)*sc2) * charfun2(s, pivot, inf))));

mirror_element(c):= block([l, s, x, y],
  l: c(s),
  if not listp(l) or length(l)#2 then error("c(s) should return a two elements list"),
  x: first(l), y: -second(l),
  buildq([x, y], lambda([s], [x, y])));

/*draw2d(point_size=3, points ( [p1, p2, p3] )); */

/* Transfinite interpolation */
gordon(c1, c2, c3, c4):=
(if not_approx_equal(c1(0), c2(0)) then error("gordon: c1(0) # c2(0)"),
  if not_approx_equal(c1(1), c4(0)) then error("gordon: c1(1) # c4(0)"),
  if not_approx_equal(c4(1), c3(1)) then error("gordon: c4(1) # c3(1)"),
  if not_approx_equal(c2(1), c3(0)) then error("gordon: c2(1) # c3(0)"),
buildq([c1, c2, c3, c4],
  lambda([u, v],
    (1-v)*c1(u)+v*c3(u)+(1-u)*c2(v)+u*c4(v)-
    ((1-u)*(1-v)*c1(0)+u*v*c3(1)+u*(1-v)*c4(0)+(1-u)*v*c3(0)))))$

create_par(x0, y0, x1, y1):= block([c1, c2, c3, c4],
  c1: create_line(x1, y0, x0, y0),
  c2: create_line(x1, y0, x1, y1),
  c3: create_line(x1, y1, x0, y1),
  c4: create_line(x0, y0, x0, y1),
  [c1, c2, c3, c4]);

ijk2n(i, j, k, nx, ny, nz):= (i-1) + (j-1)*nx + (k-1)*nx*ny;

n2ijk(n      , nx, ny, nz):= block([i, j, k],
  k: quotient(n, nx*ny),
  j: quotient(n - k*nx*ny, nx),
  i: n - k*nx*ny - j*nx,
  [i+1, j+1, k+1])$

block2n(R):=second(R);
block2array(R):=first(R);

blockijk2xyz([l]):=apply('blockijk2xyz_aux, cons(first(l), flatten(rest(l))));
blockijk2xyz_aux(R, i, j, k):= block([nlist: block2n(R), nidx,  B],
  nidx: apply('ijk2n, append([i, j, k], nlist)),
  B: block2array(R),
  maplist( lambda([D], arrayapply(D, [nidx])), B));

/*
(%i1) decodeijk(['end, 'half, 3], [10, 20, 30]);
(%o1)                             [10, 10, 3]
(%i2) 
*/
decodeijk(l, nlist):= block([out: [], el, nel],
  for idx thru length(l) do
  (el: part(l, idx),
    nel: psubst(['min=1, 'start=1,
      'max=part(nlist, idx), 'end=part(nlist, idx),
      'half=quotient(part(nlist, idx), 2)],
      el),
    nel: ev(nel, numer),
    out: endcons(nel, out)),
  out);

block2coners(R):= block([nlist: block2n(R), l, lm, p],
  l: [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]],
  lm: fullmap( lambda([s], if s=1 then 'max else 'min), l),
  p: maplist( lambda([q], decodeijk(q, nlist)), lm),
  p: maplist( lambda([q], blockijk2xyz(R, q)),  p),
  maplist("[", l, p));

is_matching(p1, p2):= block([d: vabs(second(p1) - second(p2))], approx_equal(d, 0));

/*
(%o1) [[[1, 0, 0], [0, 0, 0]], [[1, 0, 1], [0, 0, 1]], [[1, 1, 0], [0, 1, 0]], 
                                                        [[1, 1, 1], [0, 1, 1]]]
*/
matching_corners(C1, C2):= block([out: []],
  for p1 in C1 do
  for p2 in C2 do if is_matching(p1, p2) then
  out: endcons([first(p1), first(p2)], out),
  out);

/*
mc: [[[1,0,0],[0,0,0]],[[1,0,1],[0,0,1]],[[1,1,0],[0,1,0]],[[1,1,1],[0,1,1]]]$
*/

/*
(%i1) allsame([1, 1]);
(%o1)                                  1
(%i2) allsame([1, 2]);
(%o2)                              not_same
*/
allsame(l):= if not listp(l) or emptyp(l) then error("allsame argument must be a list with at least on element")
else catch(block([s: first(l)],
    for q in rest(l) do if q#s then throw('not_same), s));

nth_in_list(l, n):= maplist( lambda([q], part(q, n)), l);
mc2faces_aux(l):= catch(for nd thru 3 do block([aux: nth_in_list(l, nd), s],
    s: allsame(aux),
    if s#'not_same then throw([nd, s])),
  error("cannot find an index same for all points"));

idxp(q):= member(q, ['i, 'j, 'k]);
matchdeclare([idx1, idx2], idxp);
defmatch(find_idx, [[idx1, n1], [idx2, n2]], n1, n2);

find_changing(A, B):= if second(first(A))#second(first(B)) then endcons(second(first(B)), first(A))
else endcons(second(second(B)), second(A));

mc2faces_and_directions(mc):= block([%fs1%, %fs2%, dir],
  dir: mc2faces(mc),
  append([%fs1%, %fs2%], dir));

blocks2faces_and_directions(R1, R2):= block([co1, co2, mc],
  co1: block2coners(R1),
  co2: block2coners(R2),
  mc : matching_corners(co1, co2),
  if emptyp(mc) then return([]),
  if length(mc)#4 then return([]),
  mc2faces_and_directions(mc));

mc2faces(mc):= block([fs, cons_dim, cd1, cd2, i1, i2, widx1, widx2, d1, d2,
  pl1: maplist('first, mc),
  pl2: maplist('second, mc)],
  cd1: mc2faces_aux(pl1),
  cd2: mc2faces_aux(pl2),
  %fs1%: dimanddip2face(cd1),
  %fs2%: dimanddip2face(cd2),
  widx1: append_dim_name_but(pl1, first(cd1)),
  widx2: append_dim_name_but(pl2, first(cd2)),
  i1: first(sublist_indices(widx1, lambda([q], find_idx(q, 0, 0)#false))),
  i2: first(sublist_indices(widx1, lambda([q], find_idx(q, 1, 0)#false))),
  d1: cons(part(widx1, i1, 1, 1), find_changing(part(widx2, i1), part(widx2, i2))),
  i2: first(sublist_indices(widx1, lambda([q], find_idx(q, 0, 1)#false))),
  d2: cons(part(widx1, i2, 2, 1), find_changing(part(widx2, i1), part(widx2, i2))),
  [d1, d2]);

remove_if_index(l, index):= block([out: []], for i thru length(l) do if i#index then out: cons(part(l, i), out), reverse(out));
append_dim_name_but(pl, cd):= block([al: makelist(maplist("[", ['i, 'j, 'k], point), point, pl)],
  maplist(lambda([q], remove_if_index(q, cd)), al));

/*
   ndim: dimension code (1, 2, 3)
   deep: 0 or 1
*/
dimanddip2face([l]):= apply('dimanddip2face_aux, flatten(l));
dimanddip2face_aux(ndim, deep):=
if      ndim=1 and deep=0 then 1
else if ndim=1 and deep=1 then 2
else if ndim=2 and deep=0 then 3
else if ndim=2 and deep=1 then 4
else if ndim=3 and deep=0 then 5
else if ndim=3 and deep=1 then 6
else error("wrong ndim or deep");

win2idx(bl, iwin):=flatten(maplist("[", [1, 1],
    indexfilter(block2n(bl)-1, face2bool(iwin))));

face2bool(face):=
if      face=1 then [false, 2, 3]
else if face=2 then [false, 2, 3]
else if face=3 then [3, false, 1]
else if face=4 then [3, false, 1]
else if face=5 then [1, 2, false]
else if face=6 then [1, 2, false]
else error("face should be in range 1-6");

block2facecenter(R, face):= block([nlist: block2n(R), code, decode],
  code : if face=1 then ['min, 'half, 'half]
  else if face=2 then ['max, 'half, 'half]
  else if face=3 then ['half, 'min, 'half]
  else if face=4 then ['half, 'max, 'half]
  else if face=5 then ['half, 'half, 'min]
  else if face=6 then ['half, 'half, 'max]
  else error("face should be in range 1-6"),
  decode: decodeijk(code, nlist),
  blockijk2xyz(R, decode));

blockijk2xyz_withcode(R, l):= block([nlist: block2n(R), decode],
  decode: apply('decodeijk, [l, nlist]),
  blockijk2xyz(R, decode));

vlenght(R):= sqrt(R.R);
block2vector(B, ndim, len):= block([dR, R0: blockijk2xyz(B, 1, 1, 1)],
if ndim=1 then dR: blockijk2xyz(B, 2, 1, 1) - R0
else if ndim=2 then dR: blockijk2xyz(B, 1, 2, 1) - R0
else if ndim=3 then dR: blockijk2xyz(B, 1, 1, 2) - R0
else error("ndim should be 1, 2 or 3"),
[R0, len*dR/vlenght(dR)]);

list_to_zero_one(lst)::= buildq([lst],
  maplist(change_scale(first(lst), last(lst), 0, 1), lst));

create_rhs_output(fname, fbody)::= block([body: optimize(fbody)], buildq([body, fname],
    block(mode_declare([functions(fname), u, v, q], float),
      body)));

ijk2n_rev(i, j, k, nx, ny, nz):=block([prederror: true],
  if not every('numberp, [i, j, k, nx, ny, nz]) then error("ijk2n_rev: all arguments should be numbers"),
  if %revx% then i: nx - i + 1,
  if %revy% then j: ny - j + 1,
  if %revz% then k: nz - k + 1,
  (i-1) + (j-1)*nx + (k-1)*nx*ny);

setup_rev(rev):=  if emptyp(rev)
then (%revx%: false, %revy%: false, %revz%: false)
else (rev: first(rev),
  if not listp(rev) or length(rev)#3 then error("rev should be a list of length 3"),
  %revx%: first(rev), %revy%: second(rev), %revz%: third(rev));

output_block(B, c1lst, c2lst, [rev]):=block([lst1, lst2, lst3, u, v, q, nu, nv, nq, Rx, Ry, Rz, %revx%, %revy%, %revz%,
  c3lst: [1, 2, 3]],
  local(B, Bx, By, Bz),
  setup_rev(rev),
  define(Bx(u, v, q), create_rhs_output(Bx, float(part(B(u, v), 1)))),
  define(By(u, v, q), create_rhs_output(By, float(part(B(u, v), 2)))),
  define(Bz(u, v, q), create_rhs_output(Bz, 2*q)),
  compile(Bx, By, Bz),
  array(lst1, flonum, length(c1lst)-1),
  array(lst2, flonum, length(c2lst)-1),
  array(lst3, flonum, length(c3lst)-1),
  fillarray(lst1, list_to_zero_one(c1lst)),
  fillarray(lst2, list_to_zero_one(c2lst)),
  fillarray(lst3, list_to_zero_one(c3lst)),
  nu: length(c1lst),
  nv: length(c2lst),
  nq: length(c3lst),
  ?meval(buildq([idx: funmake('ijk2n_rev, ['i,'j,'k, nu, nv, nq]),
      n: nu*nv*nq],
    (Rx: make_array(flonum, n), Ry: make_array(flonum, n), Rz: make_array(flonum, n),
    for i: 1 thru nu do
    for j: 1 thru nv do
    for k: 1 thru nq do
    block([u: lst1[i-1], v: lst2[j-1], q: lst3[k-1]],
      Rx[idx]: float(Bx(u, v, q)), Ry[idx]: float(By(u, v, q)), Rz[idx]: float(Bz(u, v, q)))))),
  remarray(lst1, lst2, lst3),
   [[Rx, Ry, Rz], [nu, nv, nq]]);

/*
P[1,4]: [0, 0];
P[3,4]: [0, 1];
P[2,3]: [1, 1];
P[1,2]: [1, 0];

c1: create_line(P[1,2], P[1,4]);
c2: create_line(P[1,2], P[2,3]);
c3: create_line(P[2,3], P[3,4]);
c4: create_line(P[1,4], P[3,4]);

G: gordon(c1, c2, c3, c4);

load("integer_sequence");
R: first(output_block(G, 0 .. 30, 0 .. 30))$

load("draw");
draw2d( point_size=3, points(first(R), second(R)) )$


draw2d(xrange=[-2, 2], yrange=[-2, 2], point_size=3, points(R));

c1lst: 0 .. 11;
lst1: maplist(change_scale(first(c1lst), last(c1lst), 0, 1), c1lst);
lst2: change_scale(first(c2lst), last(c2lst), 0, 1),
create_list(B(u, v), v, lst1, u, lst2);
*/