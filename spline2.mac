load("spline-utils.mac");

/*

http://duns.sourceforge.net/fig1.png
http://en.wikipedia.org/wiki/Transfinite_interpolation

*/
%x%(s):=ax*s + bx;
%y%(s):=ay*s + by;
%so%: first(solve([%x%(0)=x1, %y%(0)=y1, %x%(1)=x2,  %y%(1)=y2], [ax, bx, ay, by]));

/* create parameteric line from [x1, y1] to [x2, y2]
p: create_line(0, 0, 1, 2);
draw2d(parametric( p(s)[1], p(s)[2], s, 0, 1));
*/
create_line([l]):= apply(create_line_aux, flatten(l));
create_line_aux(x1, y1, x2, y2):= buildq([X: ev(subst(%so%, %x%(s))), Y: ev(subst(%so%, %y%(s)))],
  lambda([s], [X, Y]));

/* create parameteric arc with a center [xc, yc] 
p: create_arc( [1, 1], 2, 45, 45+180 );
draw2d(xrange=[-3, 3], yrange=[-3, 3], parametric( p(s)[1], p(s)[2], s, 0, 1));
*/
create_arc([l]):= apply(create_arc_aux, flatten(l));
create_arc_aux(xc, yc, radius, phi_start, phi_end):= block([s],
  buildq([xc, yc, radius, sc: change_scale(0, 1, phi_start, phi_end)(s)],
    lambda([s], [xc + radius*cos(sc/180*%pi), yc + radius*sin(sc/180*%pi)])));

join_elements(el1, L1, el2, L2):= block([
  pivot: L1/(L1+L2),
  sc1: (L1+L2)/L1,
  sc2: (L1+L2)/L2],
  buildq([pivot, sc1, sc2, el1, el2],
    lambda([s], 
      el1(sc1*s)* charfun2(s, minf, pivot) + el2( (s - pivot)*sc2) * charfun2(s, pivot, inf))));

mirror_element(c):= block([l, s, x, y],
  l: c(s),
  if not listp(l) or length(l)#2 then error("c(s) should return a two elements list"),
  x: first(l), y: -second(l),
  buildq([x, y], lambda([s], [x, y])));

/*draw2d(point_size=3, points ( [p1, p2, p3] )); */

/* Transfinite interpolation */
gordon(c1, c2, c3, c4):=
(if not_approx_equal(c1(0), c2(0)) then error("gordon: c1(0) # c2(0)"),
  if not_approx_equal(c1(1), c4(0)) then error("gordon: c1(1) # c4(0)"),
  if not_approx_equal(c4(1), c3(1)) then error("gordon: c4(1) # c3(1)"),
  if not_approx_equal(c2(1), c3(0)) then error("gordon: c2(1) # c3(0)"),
buildq([c1, c2, c3, c4],
  lambda([u, v],
    (1-v)*c1(u)+v*c3(u)+(1-u)*c2(v)+u*c4(v)-
    ((1-u)*(1-v)*c1(0)+u*v*c3(1)+u*(1-v)*c4(0)+(1-u)*v*c3(0)))))$

create_par(x0, y0, x1, y1):= block([c1, c2, c3, c4],
  c1: create_line(x1, y0, x0, y0),
  c2: create_line(x1, y0, x1, y1),
  c3: create_line(x1, y1, x0, y1),
  c4: create_line(x0, y0, x0, y1),
  [c1, c2, c3, c4]);

ijk2n(i, j, k, nx, ny, nz):= (i-1) + (j-1)*nx + (k-1)*nx*ny;

n2ijk(n      , nx, ny, nz):= block([i, j, k],
  k: quotient(n, nx*ny),
  j: quotient(n - k*nx*ny, nx),
  i: n - k*nx*ny - j*nx,
  [i+1, j+1, k+1])$

block2n(R):=second(R);
block2array(R):=first(R);
blockijk2xyz(R, i, j, k):= block([nlist: block2n(R), nidx,  B],
  nidx: apply('ijk2n, append([i, j, k], nlist)),
  B: block2array(R),
  maplist( lambda([D], arrayapply(D, [nidx])), B));

vlenght(R):= sqrt(R.R);
block2vector(B, ndim, len):= block([dR, R0: blockijk2xyz(B, 1, 1, 1)],
if ndim=1 then dR: blockijk2xyz(B, 2, 1, 1) - R0
else if ndim=2 then dR: blockijk2xyz(B, 1, 2, 1) - R0
else if ndim=3 then dR: blockijk2xyz(B, 1, 1, 2) - R0
else error("ndim should be 1, 2 or 3"),
[R0, len*dR/vlenght(dR)]);

list_to_zero_one(lst)::= buildq([lst],
  maplist(change_scale(first(lst), last(lst), 0, 1), lst));

create_rhs_output(fname, fbody)::= block([body: optimize(fbody)], buildq([body, fname],
    block(mode_declare([functions(fname), u, v, q], float),
      body)));

ijk2n_rev(i, j, k, nx, ny, nz):=block([prederror: true],
  if %revx% then i: nx - i + 1,
  if %revy% then j: ny - j + 1,
  if %revz% then k: nz - k + 1,
  (i-1) + (j-1)*nx + (k-1)*nx*ny);

setup_rev(rev):=  if emptyp(rev)
then (%revx%: false, %revy%: false, %revz%: false)
else (rev: first(rev),
  if not listp(rev) or length(rev)#3 then error("rev should be a list of length 3"),
  %revx%: first(rev), %revy%: second(rev), %revz%: third(rev));

output_block(B, c1lst, c2lst, [rev]):=block([lst1, lst2, lst3, u, v, q, nu, nv, nq, Rx, Ry, Rz, %revx%, %revy%, %revz%,
  c3lst: [1, 2, 3]],
  local(B, Bx, By, Bz),
  setup_rev(rev),
  define(Bx(u, v, q), create_rhs_output(Bx, float(part(B(u, v), 1)))),
  define(By(u, v, q), create_rhs_output(By, float(part(B(u, v), 2)))),
  define(Bz(u, v, q), create_rhs_output(Bz, q)),
  compile(Bx, By, Bz),
  array(lst1, flonum, length(c1lst)-1),
  array(lst2, flonum, length(c2lst)-1),
  array(lst3, flonum, length(c3lst)-1),
  fillarray(lst1, list_to_zero_one(c1lst)),
  fillarray(lst2, list_to_zero_one(c2lst)),
  fillarray(lst3, list_to_zero_one(c3lst)),
  nu: length(c1lst),
  nv: length(c2lst),
  nq: length(c3lst),
  ?meval(buildq([idx: ijk2n_rev(i,j,k, nu, nv, nq),
      n: nu*nv*nq],
    (Rx: make_array(flonum, n), Ry: make_array(flonum, n), Rz: make_array(flonum, n),
    for i: 1 thru nu do
    for j: 1 thru nv do
    for k: 1 thru nq do
    block([u: lst1[i-1], v: lst2[j-1], q: lst3[k-1]],
      Rx[idx]: float(Bx(u, v, q)), Ry[idx]: float(By(u, v, q)), Rz[idx]: float(Bz(u, v, q)))))),
  remarray(lst1, lst2, lst3),
  [[Rx, Ry, Rz], [nu, nv, nq]]);

/*
P[1,4]: [0, 0];
P[3,4]: [0, 1];
P[2,3]: [1, 1];
P[1,2]: [1, 0];

c1: create_line(P[1,2], P[1,4]);
c2: create_line(P[1,2], P[2,3]);
c3: create_line(P[2,3], P[3,4]);
c4: create_line(P[1,4], P[3,4]);

G: gordon(c1, c2, c3, c4);

load("integer_sequence");
R: first(output_block(G, 0 .. 30, 0 .. 30))$

load("draw");
draw2d( point_size=3, points(first(R), second(R)) )$

*/

/*
draw2d(xrange=[-2, 2], yrange=[-2, 2], point_size=3, points(R));

c1lst: 0 .. 11;
lst1: maplist(change_scale(first(c1lst), last(c1lst), 0, 1), c1lst);
lst2: change_scale(first(c2lst), last(c2lst), 0, 1),
create_list(B(u, v), v, lst1, u, lst2);
*/