/*

0<= xi <= 1
0<= et <= 1
0<= dz <= 1

*/

/*
gordon1973.pdf, eq (17)
*/

/*
map [0, h]x[0, h]

*/

/*
h -> 1;
s -> v
t -> u
*/

F(s, t);

/* projection */
fa(f, [l])::= buildq([f, l], funmake(f, l));
Ps(f)::= buildq([body: (1-'s/'h)*fa(f, 0, 't) + ('s/'h)*fa(f, 'h, 't)], lambda([s, t], body));
Pt(f)::= buildq([body: (1-'t/'h)*fa(f, 's, 0) + ('t/'h)*fa(f, 's, 'h)], lambda([s, t], body));

expr_ref:     (1-v)*c1(u)+v*c3(u)+(1-u)*c2(v)+u*c4(v)-
    ((1-u)*(1-v)*c1(0)+u*v*c3(1)+u*(1-v)*c4(0)+(1-u)*v*c3(0))$

expr: (1-s/h)*F(0,t) + (s/h)*F(h, t)
+ (1-t/h)*F(s,0) + (t/h)*F(s, h)
- (1-s/h)*(1-t/h)*F(0,0) - (1-s/h)*(t/h)*F(0,h)
- (1-t/h)*(s/h)*F(h,0) - (t/h)*(s/h)*F(h,h);
    
load("simplifying.lisp");
simp_F(s, t):=
     if s=0  and t=0  then c1(0)
else if s=0  and t='h then c4(0)
else if s='h and t=0 then  c3(0)
else if s='h and t='h then c3(h)
else if s=0 then c1(t)
else if s='h then c3(t)
else if t=0 then  c2(s)
else if t='h then c4(s)
else simpfuncall('F, s, t);

simplifying('F,'simp_F)$


expr: subst([h=1, s=v, t=u], expr);

fullratsimp(expr_ref - expr);